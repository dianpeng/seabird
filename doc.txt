Seabird a tree structure query language
======================================

This is a rewrite of a tree query language I've written while at work. The one that I write
at work is not open source and implemented in C++ with some customize need. This version is a
rewrite of the tree query language that I have at work in Javascript.

## Language

### 1. Type
The language has a simple type system though it is weak type inheritedly. There're several types :

1. number (double)
2. string
3. null
4. list
5. pair
6. dict
7. function

### 2. Grammar

The following informal BNF is used to describe the grammar
 
@main : query-expression

query-expression := query-variable ? query
query-variable   := 'let' VARIABLE '=' query (',' VARIABLE = query)*

// query definition
query            := primary |
                    prefix  |
                    unary   |
                    binary  |
                    ternary

primary          := constant |
                    compound |
                    THIS     |
                    function |
                    VARIABLE |
                    ATTRIBUTE

compound         := list     |
                    pair     |
                    dict

list             := '[' list-element ']'
list-element     := __empty__  |
                    query (',' query)*

pair             := '(' query ':' query ')'

dict             := '{' dict-element '}'
dict-element     := __empty__  |
                    query ':' query (',' query ':' query )*

constant         := NUMBER |
                    STRING |
                    NULL

prefix           := primary |
                    primary prefix-index

prefix-comp      := ('.' VARIABLE)     |
                    ('[' squery ']')   |
                    ('(' arg-list ')') |
                    ('[?' query ']')   |
                    ('[|' query ']')

squery           := query (':' query ':' query)
arg-list         := query (',' query)*
prefix-index     := prefix-comp prefix-comp*

function         := 'fn' '(' arg-define ')' query
arg-define       := VARIABLE (',' VARIABLE)*

// expression level
unary            := prefix | ( '+' | '!' ) prefix
binary           := arith  | comp
factor           := unary  | unary ( "*" | "/" ) factor
term             := factor | factor ( "+" | "-" ) term
arith            := factor | term
comp             := gtls   | equal
gtls             := arith ( '<' | '>' | '<=' | '>=' ) gtls
equal            := equal ( '==' | '!=' ) equal
unary            := binary | binary 'if' binary 'else' binary
query            := unary
